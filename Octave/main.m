close allclearclc# This is an integrated example that comprises# source "./total_least_squares.m"source "./total_least_squares_projections.m"# synthesis of the virtual world#num_landmarks=100;#num_poses=10;#world_size=10;# landmarks in a matrix, one per column#P_world=(rand(landmark_dim, num_landmarks)-0.5)*world_size;global K; % camera matrixglobal image_rows;global image_cols;################################## TRAJECTORY ##################################datFile = '../dataset/trajectory.dat';[a, id, xg, yg, tg, x, y, t] = textread (datFile, "%s %d %f %f %f %f %f %f");num_poses = id(end)+1;XR_true=zeros(4,4,num_poses);XR_guess=zeros(4,4,num_poses);for (pose_num=1:num_poses)    u = [x(pose_num); y(pose_num); 0; 0; 0; t(pose_num)];    Xr=v2t(u);    XR_true(:,:,pose_num)=Xr;        ug = [xg(pose_num); yg(pose_num); 0; 0; 0; tg(pose_num)];    Xrg=v2t(ug);    XR_guess(:,:,pose_num)=Xrg;endfor;################################## LANDMARKS ###################################datFile = '../dataset/world.dat';[id, x, y, z, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10] = textread (datFile, "%d %f %f %f %f %f %f %f %f %f %f %f %f %f");num_landmarks = id(end)+1;# landmarks in a matrix, one per columnXL_true=[x'; y'; z'];############################ LANDMARK MEASUREMENTS ################################ generate an ideal number of landmark measurements### each pose observes each landmarknum_landmark_measurements=num_poses*num_landmarks;Zl=zeros(landmark_dim,num_landmark_measurements);landmark_associations=zeros(2,num_landmark_measurements);measurement_num=1;for (pose_num=1:num_poses)    Xr=inv(XR_true(:,:,pose_num));    for (landmark_num=1:num_landmarks)      Xl=XL_true(:,landmark_num);      landmark_associations(:,measurement_num)=[pose_num,landmark_num]';      Zl(:,measurement_num)=Xr(1:3,1:3)*Xl+Xr(1:3,4);      measurement_num++;    endfor;endfor;########################### PROJECTION MEASUREMENTS ############################# generate an ideal number of projection measurements# each pose observes each landmarknum_projection_measurements=num_poses*num_landmarks;Zp=zeros(projection_dim,num_projection_measurements);projection_associations=zeros(2,num_projection_measurements);measurement_num=1;for (pose_num=1:num_poses)    file = ["../dataset/meas-" num2str(pose_num-1,'%05d') ".dat"];    [a, id, land_id, r, c, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10] = textread (file, "%s %d %d %f %f %f %f %f %f %f %f %f %f %f %f", 'HeaderLines', 3);    for (iter=1:size(land_id,1)-1)      landmark_num = land_id(iter)+1;      projection_associations(:,measurement_num)=[pose_num; landmark_num];      Zp(:,measurement_num)=[r(iter); c(iter)];      measurement_num++;    endfor;endfor####measurement_num##sum(Zp(:))##ibis = Zp;##Zp=zeros(projection_dim,num_projection_measurements);##measurement_num=1;##for (pose_num=1:num_poses)##    #iXr = inv(cam_transform) * inv(XR_true(:,:,pose_num));##    iXr=inv(XR_true(:,:,pose_num));##    for (landmark_num=1:num_landmarks)##      #landmark_num##      Xl=XL_true(:,landmark_num);##      ##      p_img=[-1;-1];####      pw = K*iXr(1:3,1:3) * Xl + K*iXr(1:3,4);##      if !(pw(3) < z_near || pw(3) > z_far)##        p_cam=pw;##        iz=1./p_cam(3);##        p_cam*=iz;##        if !(p_cam(1)<0 || p_cam(1)>image_cols || p_cam(2)<0 || p_cam(2)>image_rows)##          p_img=p_cam(1:2);##        endif;##      endif;##      ##      if (p_img(1)>0)##        projection_associations(:,measurement_num)=[pose_num, landmark_num]';##        Zp(:,measurement_num)=p_img;##        measurement_num++;##      endif;##    endfor;##endfor##measurement_num=1;##for (pose_num=1:num_poses)##    Xr=XR_true(:,:,pose_num);##    for (landmark_num=1:num_landmarks)##      Xl=XL_true(:,landmark_num);##      z_img=projectPoint(Xr,Xl);##      if (z_img(1)>0)##        projection_associations(:,measurement_num)=[pose_num, landmark_num]';##        Zp(:,measurement_num)=z_img;##        measurement_num++;##      endif;##    endfor;##endfor##measurement_num##sum(Zp(:))##pkeyboard()# crop the projection associations to something meaningfulnum_projection_measurements=measurement_num-1;projection_associations=projection_associations(:,1:num_projection_measurements);Zp=Zp(:,1:num_projection_measurements);################################ TRIANGULATION ################################## #XL_guess = triangulate2(num_landmarks, num_poses, observations, land_apperances, XR_guess)# apply a perturbation to each landmarkpert_deviation=-0.1;XL_guess=XL_true;##dXl=(rand(landmark_dim, num_landmarks)-0.5)*pert_deviation;dXl = XL_guess * pert_deviation;XL_guess+=dXl;#num_landmarks = XL_guess.shape(1)############################## POSE MEASUREMENTS ################################ generate an odometry trajectory for the robotnum_pose_measurements=num_poses-1;Zr=zeros(4,4,num_pose_measurements);pose_associations=zeros(2,num_pose_measurements);measurement_num=1;for (pose_num=1:num_poses-1)    Xi=XR_guess(:,:,pose_num);    Xj=XR_guess(:,:,pose_num+1);    pose_associations(:,measurement_num)=[pose_num, pose_num+1]';    Zr(:,:,measurement_num)=inv(Xi)*Xj;    measurement_num++;endfor############################## CALL SOLVER  ################################## # uncomment the following to suppress pose-landmark measurements# Zl=zeros(3,0);# uncomment the following to suppress pose-landmark-projection measurements# num_landmarks=0;# Zp=zeros(3,0);# uncomment the following to suppress pose-pose measurements# Zr=zeros(4,4,0);damping=0.1;kernel_threshold=1000;num_iterations=20;##sum(XR_guess(:))##sum(XL_guess(:))##sum(Zl(:))##size(landmark_associations)##sum(Zp(:))##size(projection_associations)##sum(Zr(:))##size(pose_associations)##num_poses##num_landmarks##num_iterations##damping##kernel_threshold[XR, XL,chi_stats_l, num_inliers_l, chi_stats_p, num_inliers_p, chi_stats_r, num_inliers_r, H, b]=doTotalLS(XR_guess, XL_guess, 												      Zl, landmark_associations, 												      Zp, projection_associations, 												      Zr, pose_associations, 												      num_poses, 												      num_landmarks, 												      num_iterations, 												      damping, 												      kernel_threshold);												      												      # Plot Statefigure(1);hold on;grid;subplot(2,2,1);title("Landmark Initial Guess");plot3(XL_true(1,:),XL_true(2,:),XL_true(3,:),'b*',"linewidth",2);hold on;plot3(XL_guess(1,:),XL_guess(2,:),XL_guess(3,:),'ro',"linewidth",2);legend("Landmark True", "Guess");grid;subplot(2,2,2);title("Landmark After Optimization");plot3(XL_true(1,:),XL_true(2,:),XL_true(3,:),'b*',"linewidth",2);hold on;plot3(XL(1,:),XL(2,:),XL(3,:),'ro',"linewidth",2);legend("Landmark True", "Guess");grid;subplot(2,2,3);title("Poses Initial Guess");plot3(XR_true(1,:),XR_true(2,:),XR_true(3,:),'b*',"linewidth",2);hold on;plot3(XR_guess(1,:),XR_guess(2,:),XR_guess(3,:),'ro',"linewidth",2);legend("Poses True", "Guess");grid;subplot(2,2,4);title("Poses After Optimization");plot3(XR_true(1,:),XR_true(2,:),XR_true(3,:),'b*',"linewidth",2);hold on;plot3(XR(1,:),XR(2,:),XR(3,:),'ro',"linewidth",2);legend("Poses True", "Guess"); grid;figure(2);hold on;grid;title("chi evolution");subplot(3,2,1);plot(chi_stats_r, 'r-', "linewidth", 2);legend("Chi Poses"); grid; xlabel("iterations");subplot(3,2,2);plot(num_inliers_r, 'b-', "linewidth", 2);legend("#inliers"); grid; xlabel("iterations");subplot(3,2,3);plot(chi_stats_l, 'r-', "linewidth", 2);legend("Chi Landmark"); grid; xlabel("iterations");subplot(3,2,4);plot(num_inliers_l, 'b-', "linewidth", 2);legend("#inliers"); grid; xlabel("iterations");subplot(3,2,5);plot(chi_stats_p, 'r-', "linewidth", 2);legend("Chi Proj"); grid; xlabel("iterations");subplot(3,2,6);plot(num_inliers_p, 'b-', "linewidth", 2);legend("#inliers");grid; xlabel("iterations");figure(3);title("H matrix");H_ =  H./H;                      # NaN and 1 elementH_(isnan(H_))=0;                 # Nan to ZeroH_ = abs(ones(size(H_)) - H_);   # switch zero and oneH_ = flipud(H_);                 # switch rowscolormap(gray(64));hold on;image([0.5, size(H_,2)-0.5], [0.5, size(H_,1)-0.5], H_*64);hold off;